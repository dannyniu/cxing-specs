2025-12-11 On Implementation of Object Key-Value Reading and Writing
====

The reference implementation of CXING will use the
[SafeTypes2](https://github.com/dannyniu/SafeTypes2) facility for its runtime.
This MOD discusses the implementation stratagy of the reference implementation.

Assignment
====

As an example, on encountering an assignment expression of form:

```
hashtable.k = v
```

The value of the expression is supposedly that of `v` _after_ being assigned to
the `k` member of the object `hashtable`.

As mentioned in "_Finalization and Garbage Collection_":

> When a value is destroyed, the resources associated with it
> are finalized and ...

therefore, it's first essential to define when values are destroyed, so that
the other conditions of resource management can be decided.

Intuitively, a _variable_ is finalized when it goes out of the scope of its
declared block. The value and thus the resource referred to by the variable
may however be `__copy__`'d and `__final__`'d various times.

Back to the example:
1. The value and its resources existed in `v` at the start,
2. The value and its resources gets copied in `hashtable.k`,
3. The value of the whole expression 'disappears' when the expression ends,
   assuming it's not part of a declaration.

Here, step 2 is done by calling the `__set__` property method of `hashtable`.
There are 2 setter semantics in SafeTypes2:
- *kept*: where only the "kept count" is incremented, and
- *gave*: where the the "kept count" is incremented and the
  reference count is decremented.

A simple way to ensure the value of the assignment expression (equivalently,
the result of the `__set__` method call) is to use the *kept* semantic, and
return `v` as is.

This way, if the value of the expression is finalized, everything will be
still correct - however, as well see later on (also as I discover while drafting
this MOD), values of expressions are neither retained nor released for they're
considered transient, whereas declaration of variables creates retains, and the
paired release at scope exit.

If for some reason, *gave* was used (e.g. the value is consumed, and another is
computed from it), then additional 'retain' operation would be needed.

How should `__copy__` and `__final__` be implemented?
----

There are 2 options when implementing copy and final methods with SafeTypes2:
1. Make them operate on reference counts. The garbage collection of SafeTypes2
   would then be unable to clean up reference cycles in this case.
2. Make them operate on kept counts, and have non-zero reference count on the
   stack-frame variables. Which seems _preferable_.

Under option 2, there's the chance of another thread cleaning up an object by
invocing GC when the current thread is operating on it - this is _Not_ a problem
_If_ each thread are entered by holding the `thrd` lock, which is the thread-side
"reader" lock that prevents GC from causing accidents - GC still happens when
_all_ threads calls `cxing_gc`, which is implemented using the `s2gc_collect`
function, which in turn acquires the GC-side "writer" lock that consults the
availability of threads before taking any action on potentially dead resources.

The `s2gc_collect` function and `thrd` locks are threading aware.
See SafeTypes2 documentation for further details on this.

Retrieval
====

As an example, consider the following statement:

```
return hashtable.prop;
```

For the `prop` member of `hashtable`, we can either:
1. Retain on getting, and release on scope exit.
2. Do nothing on getting and scope exit.

For the above clause, 2 would be correct.

We don't need to retain the `prop` member value after retrieving it: we've
already used *kept* semantic with assignments, which doesn't alter the counts
of the right-hand side.

Consider another example:

```
hashtable.prop += 12;
```

This expands to the sequence:

```
hashtable.__set__("prop", hashtable.__get__("prop") + 12);
```

At first glance, it would seem `prop` would be destroyed after adding with 12,
however, if we establish that operands be not `__final__`'d after their
operations, the consistency is then restored.

At yet another glance, the *kept* semantic seem to imply that `prop` was
double-retained - this is not true as the old value of `prop` is released before
the new value takes its place within the `__set__` call.

And think about it, it's actually consistent with C++ having only copy&move
constructor&assignment operators, rather than variable reading operators.

Summary
====

When implemented using the SafeTypes2 library,
- The `__set__` method uses the *kept* container semantic.
- The `__get__` method does a 'nop' when it comes to the reference counts.
- Operands of expressions are considered transient, and their reference counts're unchanged.
- The `__copy__` and `__final__` members operate on kept counts rather than reference couns.
